
# DI (Контейнер зависимостей)
___


### Что такое DI контейнер ? 
> (Dependency Injection container или сокращенно DI контейнер) - это компонент фреймворка или приложения, который управляет зависимостями между классами. 
>
> Когда классы взаимодействуют между собой, они могут зависеть от других классов или объектов. Контейнер зависимостей облегчает управление зависимостями, поскольку он автоматически создает объекты, которые классы требуют для выполнения своей работы. 
>
> Например, если класс А зависит от класса В, то DI контейнер автоматически создаст экземпляр класса B и передаст его в качестве параметра конструктора класса A. Это позволяет избежать жестких зависимостей между классами и делает приложение более гибким и удобным для тестирования и поддержки. 
>
>DI контейнеры также позволяют легко заменять зависимости при разработке и поддержке приложения, а также улучшают читаемость кода, поскольку они облегчают понимание связей между классами и их зависимостями. 
>
> DI контейнеры широко используются в современных PHP фреймворках и являются важной составляющей архитектуры приложений.

<br/>

### Что такое сервис-провайдер ?

> (Service Provider) - это компонент фреймворка или приложения, который отвечает за регистрацию и настройку сервисов и зависимостей.
>
>Он своего рода поставщик сервисов, который определяет, какие зависимости и сервисы будут использоваться в приложении. Например, если приложение использует базу данных, сервис-провайдер может зарегистрировать соединение с базой данных и предоставить доступ к нему в других частях приложения.
>
>Сервис-провайдеры также могут выполнять другие задачи, такие как регистрация middleware, установка конфигурации приложения, настройка маршрутизации и другие операции, необходимые для запуска приложения.
>
>В многих PHP фреймворках, таких как Laravel и Symfony, сервис-провайдеры используются для организации зависимостей и настройки приложения в целом. Сервис-провайдеры помогают упростить код и повысить читаемость при обработке конфигурации приложения и регистрации сервисов и зависимостей.

<br/>

### Как связаны сервис-провайдеры и контейнер зависимостей?

> сервис-провайдеры (Service Provider) и контейнеры зависимостей (Dependency Injection container или сокращенно DI контейнер) взаимосвязаны и часто используются вместе в PHP приложениях.
>
>Контейнер зависимостей отвечает за создание и управление зависимостями в приложении, а сервис-провайдеры отвечают за регистрацию этих зависимостей с помощью методов, которые вызываются при регистрации провайдера.
>
>При регистрации сервис-провайдера в приложении, зависимости, которые он предоставляет, зарегистрируются в контейнере зависимостей. Это позволяет другим компонентам приложения получить доступ к предоставляемым зависимостям через контейнер без жесткой привязки кода между ними.
>
>Во время выполнения приложения контейнер зависимостей будет использовать зарегистрированные зависимости, чтобы внедрять их в классы и объекты, которые их требуют. Таким образом, с помощью сервис-провайдеров и контейнеров зависимостей можно эффективно организовать зависимости и сервисы в приложении, делая его более гибким и удобным для тестирования и поддержки.


``` php
Пример кода контейнера зависимостей вместе с сервис-провайдером на языке PHP:

class Container {
   private $services = array();

   public function register($serviceName, $serviceProvider) {
      $this->services[$serviceName] = $serviceProvider;
   }

   public function get($serviceName) {
      $serviceProvider = $this->services[$serviceName];
      return $serviceProvider->create($this);
   }
}

interface ServiceProvider {
   public function create($container);
}

class DatabaseServiceProvider implements ServiceProvider {
   public function create($container) {
      $connection = new PDO('mysql:host=localhost;dbname=myDatabase', 'username', 'password');
      return new DatabaseService($connection);
   }
}

class DatabaseService {
   private $connection;

   public function __construct($connection) {
      $this->connection = $connection;
   }

   public function getData() {
      // do something with the database connection
   }
}

// использование контейнера зависимостей с сервис-провайдером
$container = new Container();
$container->register('databaseService', new DatabaseServiceProvider());

$databaseService = $container->get('databaseService');
$databaseService->getData();


Пример кода контейнера зависимостей без использования сервис-провайдера:

class Container {
   private $services = array();

   public function register($serviceName, $service) {
      $this->services[$serviceName] = $service;
   }

   public function get($serviceName) {
      return $this->services[$serviceName];
   }
}

class DatabaseService {
   private $connection;

   public function __construct() {
      $this->connection = new PDO('mysql:host=localhost;dbname=myDatabase', 'username', 'password');
   }

   public function getData() {
      // do something with the database connection
   }
}

// использование контейнера зависимостей без сервис-провайдера
$container = new Container();
$container->register('databaseService', new DatabaseService());

$databaseService = $container->get('databaseService');
$databaseService->getData();


Оба этих примера демонстрируют, как использовать контейнер зависимостей 
для создания объектов и управления зависимостями в приложении. 
Однако, использование сервис-провайдера позволяет создавать и 
настраивать объекты более гибко и позволяет легче изменять их в будущем.
```

<br/>

### Как в контейнер зависимостей добавляются сервис провайдеры если в интерфейсе DI который описан в комьюнити PHP-FIG указаны только методы get и has?
>Сервис-провайдеры обычно добавляются в контейнер зависимостей с помощью методов `register()` или `add()` (в зависимости от реализации контейнера). Это методы, которые добавляют новый сервис в контейнер или заменяют существующий.
>
>Когда контейнер создает объект, он ищет в своем хранилище нужные сервисы и, если они не существуют, то он использует соответствующий сервис-провайдер, чтобы создать объект.
>
>Если интерфейс DI, определенный в PHP-FIG, содержит только методы `get()` и `has()`, то это не означает, что контейнер не может использовать сервис-провайдеры для создания объектов.
>
>Просто сервис-провайдер должен быть представлен в контейнере зависимостей с помощью соответствующего ключа, чтобы контейнер мог использовать его для создания объекта при вызове метода `get()`.
>
>Например, в классе контейнера, реализующего интерфейс DI, можно создать метод `registerServiceProvider`, который получает идентификатор сервиса и сервис-провайдер, затем использует их, чтобы зарегистрировать сервис в контейнере:
```php 

interface ContainerInterface {
    public function has($id);
    public function get($id);
}

class MyContainer implements ContainerInterface {
    private $services = array();

    public function has($id) {
        return isset($this->services[$id]);
    }

    public function get($id) {
        if ($this->has($id)) {
            return $this->services[$id]($this);
        }

        throw new Exception("Service $id not found.");
    }

    public function registerServiceProvider($id, $provider) {
        $this->services[$id] = $provider;
    }
}

$container = new MyContainer();

$container->registerServiceProvider('myService', function ($c) {
    return new MyService($c->get('dependency'));
});

$container->registerServiceProvider('dependency', function () {
    return new Dependency();
});

$myService = $container->get('myService');


В примере выше метод `registerServiceProvider()` добавляет в контейнер два сервиса: `myService` и `dependency`. 
При вызове метода `get('myService')` контейнер найдет провайдер сервиса `myService`, вызовет его и передаст 
ему экземпляр контейнера в качестве параметра, чтобы провайдер мог получить нужные зависимости из контейнера и создать объект.

Это один из способов добавления сервис-провайдеров в контейнер зависимостей, даже если интерфейс DI, определенный в PHP-FIG, содержит только методы `get()` и `has()`.
```

[<< назад](../README.md)